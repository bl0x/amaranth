from abc import abstractproperty

from ..hdl import *
from ..lib.cdc import ResetSynchronizer
from ..build import *


__all__ = ["GowinPlatform"]


class GowinPlatform(TemplatedPlatform):
    """
    .. rubric:: Apicula toolchain

    Required tools:
        * ``yosys``
        * ``nextpnr-gowin``
        * ``gowin_pack``

    The environment is populated by running the script specified in the environment variable
    ``AMARANTH_ENV_Apicula``, if present.

    Build products:
        * ``{{name}}.fs``: binary bitstream.
    """

    toolchain = None # selected when creating platform

    device  = abstractproperty()
    family  = abstractproperty()
    voltage = abstractproperty()
    size    = abstractproperty()
    package = abstractproperty()
    speed   = abstractproperty()

    @property
    def _part(self):
            return "{}-{}{}{}{}".format(self.family, self.voltage,
            self.size, self.package, self.speed)

    # Apicula templates

    _apicula_required_tools = ["yosys", "nextpnr-gowin", "gowin_pack"]

    _apicula_file_templates = {
        **TemplatedPlatform.build_script_templates,
        "{{name}}.il": r"""
            # {{autogenerated}}
            {{emit_rtlil()}}
        """,
        "{{name}}.v": r"""
            /* {{autogenerated}} */
            {{emit_verilog()}}
        """,
        "{{name}}.debug.v": r"""
            /* {{autogenerated}} */
            {{emit_debug_verilog()}}
        """,
        "{{name}}.ys": r"""
            # {{autogenerated}}
            {% for file in platform.iter_files(".v") -%}
                read_verilog {{get_override("read_verilog_opts")|options}} {{file}}
            {% endfor %}
            {% for file in platform.iter_files(".sv") -%}
                read_verilog -sv {{get_override("read_verilog_opts")|options}} {{file}}
            {% endfor %}
            {% for file in platform.iter_files(".il") -%}
                read_ilang {{file}}
            {% endfor %}
            read_ilang {{name}}.il
            delete w:$verilog_initial_trigger
            {{get_override("script_after_read")|default("# (script_after_read placeholder)")}}
            synth_gowin {{get_override("synth_opts")|options}} -top {{name}} -json {{name}}.json
            {{get_override("script_after_synth")|default("# (script_after_synth placeholder)")}}
        """,
        "{{name}}.cst": r"""
            # {{autogenerated}}
            {% for port_name, pin_name, attrs in platform.iter_port_constraints_bits() -%}
                IO_LOC "{{port_name}}" {{pin_name}};
                {% for attr_name, attr_value in attrs.items() -%}
                    IO_PORT "{{port_name}}" {{attr_name}}={{attr_value}};
                {% endfor %}
            {% endfor %}
            {% for net_signal, port_signal, frequency in platform.iter_clock_constraints() -%}
                # dummy {{net_signal|hierarchy(".")}} {{frequency/1000000}}
            {% endfor%}
            {{get_override("add_constraints")|default("# (add_constraints placeholder)")}}
        """,
    }
    _apicula_command_templates = [
        r"""
        {{invoke_tool("yosys")}}
            {{quiet("-q")}}
            {{get_override("yosys_opts")|options}}
            -l {{name}}.rpt
            {{name}}.ys
        """,
        r"""
        {{invoke_tool("nextpnr-gowin")}}
            {{quiet("--quiet")}}
            {{get_override("nextpnr_opts")|options}}
            --log {{name}}.tim
            --device {{platform._part}}
            --family {{platform.device}}
            --json {{name}}.json
            --cst {{name}}.cst
            --write {{name}}.json
        """,
        r"""
        {{invoke_tool("gowin_pack")}}
            {{verbose("-v")}}
            -d {{platform.device}}
            -o {{name}}.fs
            {{name}}.json
        """
    ]

    def __init__(self, *, toolchain="Apicula"):
        super().__init__()

        assert toolchain in ("Apicula",)
        self.toolchain = toolchain

    @property
    def _toolchain_env_var(self):
        if self.toolchain == "Apicula":
            return f"AMARANTH_ENV_{self.toolchain}"
        assert False

    @property
    def required_tools(self):
        if self.toolchain == "Apicula":
            return self._apicula_required_tools
        assert False

    @property
    def file_templates(self):
        if self.toolchain == "Apicula":
            return self._apicula_file_templates
        assert False

    @property
    def command_templates(self):
        if self.toolchain == "Apicula":
            return self._apicula_command_templates
        assert False

    @property
    def default_clk_constraint(self):
        # Use the defined Clock resource.
        return super().default_clk_constraint

    def _get_io_buffer(self, m, pin, io_type, i_invert=False, o_invert=False):

        def get_ineg(y, invert):
            if invert:
                a = Signal.like(y, name_suffix="_n")
                m.d.comb += y.eq(~a)
                return a
            else:
                return y

        def get_oneg(a, invert):
            if invert:
                y = Signal.like(a, name_suffix="_n")
                m.d.comb += y.eq(~a)
                return y
            else:
                return a


        if "i" in pin.dir:
            pin_i = get_ineg(pin.i, i_invert)
        if "o" in pin.dir:
            pin_o = get_oneg(pin.o, o_invert)

        i = o = t = None

        if "i" in pin.dir:
            i = Signal(pin.width, name="{}_xdr_i".format(pin.name))
        if "o" in pin.dir:
            o = Signal(pin.width, name="{}_xdr_o".format(pin.name))

        if pin.xdr == 0:
            if "i" in pin.dir:
                i = pin_i
            if "o" in pin.dir:
                o = pin_o

        return (i, o, t)

    def get_input(self, pin, port, attrs, invert):
        self._check_feature("single-ended input", pin, attrs,
                            valid_xdrs=(0, 1, 2), valid_attrs=True)
        m = Module()
        i, o, t = self._get_io_buffer(m, pin, attrs.get("IO_TYPE"),
                                      i_invert=invert)
        for bit in range(pin.width):
            m.submodules["{}_{}".format(pin.name, bit)] = Instance("IBUF",
                i_I=port.io[bit],
                o_O=i[bit]
            )
        return m

    def get_output(self, pin, port, attrs, invert):
        self._check_feature("single-ended output", pin, attrs,
                            valid_xdrs=(0, 1, 2), valid_attrs=True)
        m = Module()
        i, o, t = self._get_io_buffer(m, pin, port.io, attrs.get("IO_TYPE"),
                                      o_invert=invert)
        for bit in range(pin.width):
            m.submodules["{}_{}".format(pin.name, bit)] = Instance("OBUF",
                i_I=o[bit],
                o_O=port.io[bit]
            )
        return m
