from abc import abstractproperty

from ..hdl import *
from ..lib.cdc import ResetSynchronizer
from ..build import *


__all__ = ["GowinPlatform"]


class GowinPlatform(TemplatedPlatform):
    """
    .. rubric:: Apicula toolchain

    Required tools:
        * ``yosys``
        * ``nextpnr-gowin``
        * ``gowin_pack``

    The environment is populated by running the script specified in the environment variable
    ``AMARANTH_ENV_Apicula``, if present.

    Build products:
        * ``{{name}}.fs``: binary bitstream.
    """

    toolchain = None # selected when creating platform

    device  = abstractproperty()
    family  = abstractproperty()
    voltage = abstractproperty()
    size    = abstractproperty()
    package = abstractproperty()
    speed   = abstractproperty()
    board   = abstractproperty()

    @property
    def _part(self):
            return "{}-{}{}{}{}".format(self.family, self.voltage,
            self.size, self.package, self.speed)

    # Apicula templates

    _apicula_required_tools = ["yosys", "nextpnr-gowin", "gowin_pack"]

    _apicula_file_templates = {
        **TemplatedPlatform.build_script_templates,
        "{{name}}.il": r"""
            # {{autogenerated}}
            {{emit_rtlil()}}
        """,
        "{{name}}.v": r"""
            /* {{autogenerated}} */
            {{emit_verilog()}}
        """,
        "{{name}}.debug.v": r"""
            /* {{autogenerated}} */
            {{emit_debug_verilog()}}
        """,
        "{{name}}.ys": r"""
            # {{autogenerated}}
            {% for file in platform.iter_files(".v") -%}
                read_verilog {{get_override("read_verilog_opts")|options}} {{file}}
            {% endfor %}
            {% for file in platform.iter_files(".sv") -%}
                read_verilog -sv {{get_override("read_verilog_opts")|options}} {{file}}
            {% endfor %}
            {% for file in platform.iter_files(".il") -%}
                read_ilang {{file}}
            {% endfor %}
            read_ilang {{name}}.il
            delete w:$verilog_initial_trigger
            {{get_override("script_after_read")|default("# (script_after_read placeholder)")}}
            synth_gowin {{get_override("synth_opts")|options}} -top {{name}}
            {{get_override("script_after_synth")|default("# (script_after_synth placeholder)")}} -json {{name}}.json
        """,
        "{{name}}.cst": r"""
            # {{autogenerated}}
            IO_LOC "clk" 52
            IO_LOC "rst" 4
            {% for port_name, pin_name, attrs in platform.iter_port_constraints_bits() -%}
                IO_LOC "{{port_name}}" {{pin_name}};
                {% for attr_name, attr_value in attrs.items() -%}
                    IO_PORT "{{port_name}}" {{attr_name}}={{attr_value}};
                {% endfor %}
            {% endfor %}
            {% for net_signal, port_signal, frequency in platform.iter_clock_constraints() -%}
                IO_LOC {{net_signal|hierarchy(".")}} {{frequency/1000000}}
            {% endfor%}
            {{get_override("add_constraints")|default("# (add_constraints placeholder)")}}
        """,
    }
    _apicula_command_templates = [
        r"""
        {{invoke_tool("yosys")}}
            {{quiet("-q")}}
            {{get_override("yosys_opts")|options}}
            -l {{name}}.rpt
            {{name}}.ys
        """,
        r"""
        {{invoke_tool("nextpnr-gowin")}}
            {{quiet("--quiet")}}
            {{get_override("nextpnr_opts")|options}}
            --log {{name}}.tim
            --device {{platform._part}}
            --family {{patform.device}}
            --json {{name}}.json
            --cst {{name}}.cst
            --write {{name}}.json
        """,
        r"""
        {{invoke_tool("gowin_pack")}}
            {{verbose("-v")}}
            -d {{platform.family}}
            -o {{name}}.fs
            {{name}}.json
        """
    ]

    def __init__(self, *, toolchain="Apicula"):
        super().__init__()

        assert toolchain in ("Apicula")
        self.toolchain = toolchain

    @property
    def _toolchain_env_var(self):
        if self.toolchain == "Apicula":
            return f"AMARANTH_ENV_{self.toolchain}"
        assert False

    @property
    def required_tools(self):
        if self.toolchain == "Apicula":
            return self._apicula_required_tools
        assert False

    @property
    def file_templates(self):
        if self.toolchain == "Apicula":
            return self._apicula_file_templates
        assert False

    @property
    def command_templates(self):
        if self.toolchain == "Apicula":
            return self._apicula_command_templates
        assert False

    @property
    def default_clk_constraint(self):
        # Use the defined Clock resource.
        return super().default_clk_constraint

#    def _get_io_buffer(self, m, pin, port, attrs, *, i_invert=False,
#                       o_invert=False,
#                       invert_lut=False):
#        def get_dff(clk, d, q):
#            m.submodules += Instance("$dff",
#                p_CLK_POLARITY=1,
#                p_WIDTH=len(d),
#                i_CLK=clk,
#                i_D=d,
#                o_Q=q)
#
#        def get_ineg(y, invert):
#            if invert_lut:
#                a = Signal.like(y, name_suffix="_x{}".format(1 if invert else 0))
#                for bit in range(len(y)):
#                    m.submodules += Instance("SB_LUT4",
#                        p_LUT_INIT=Const(0b01 if invert else 0b10, 16),
#                        i_I0=a[bit],
#                        i_I1=Const(0),
#                        i_I2=Const(0),
#                        i_I3=Const(0),
#                        o_O=y[bit])
#                return a
#            elif invert:
#                a = Signal.like(y, name_suffix="_n")
#                m.d.comb += y.eq(~a)
#                return a
#            else:
#                return y
#
#        def get_oneg(a, invert):
#            if invert_lut:
#                y = Signal.like(a, name_suffix="_x{}".format(1 if invert else 0))
#                for bit in range(len(a)):
#                    m.submodules += Instance("SB_LUT4",
#                        p_LUT_INIT=Const(0b01 if invert else 0b10, 16),
#                        i_I0=a[bit],
#                        i_I1=Const(0),
#                        i_I2=Const(0),
#                        i_I3=Const(0),
#                        o_O=y[bit])
#                return y
#            elif invert:
#                y = Signal.like(a, name_suffix="_n")
#                m.d.comb += y.eq(~a)
#                return y
#            else:
#                return a
#
#        if "GLOBAL" in attrs:
#            is_global_input = bool(attrs["GLOBAL"])
#            del attrs["GLOBAL"]
#        else:
#            is_global_input = False
#        assert not (is_global_input and i_invert)
#
#        if "i" in pin.dir:
#            if pin.xdr < 2:
#                pin_i  = get_ineg(pin.i,  i_invert)
#            elif pin.xdr == 2:
#                pin_i0 = get_ineg(pin.i0, i_invert)
#                pin_i1 = get_ineg(pin.i1, i_invert)
#        if "o" in pin.dir:
#            if pin.xdr < 2:
#                pin_o  = get_oneg(pin.o,  o_invert)
#            elif pin.xdr == 2:
#                pin_o0 = get_oneg(pin.o0, o_invert)
#                pin_o1 = get_oneg(pin.o1, o_invert)
#
#        if "i" in pin.dir and pin.xdr == 2:
#            i0_ff = Signal.like(pin_i0, name_suffix="_ff")
#            i1_ff = Signal.like(pin_i1, name_suffix="_ff")
#            get_dff(pin.i_clk, i0_ff, pin_i0)
#            get_dff(pin.i_clk, i1_ff, pin_i1)
#        if "o" in pin.dir and pin.xdr == 2:
#            o1_ff = Signal.like(pin_o1, name_suffix="_ff")
#            get_dff(pin.o_clk, pin_o1, o1_ff)
#
#        for bit in range(len(port)):
#            io_args = [
#                ("io", "PACKAGE_PIN", port[bit]),
#                *(("p", key, value) for key, value in attrs.items()),
#            ]
#
#            if "i" not in pin.dir:
#                # If no input pin is requested, it is important to use a non-registered input pin
#                # type, because an output-only pin would not have an input clock, and if its input
#                # is configured as registered, this would prevent a co-located input-capable pin
#                # from using an input clock.
#                i_type =     0b01 # PIN_INPUT
#            elif pin.xdr == 0:
#                i_type =     0b01 # PIN_INPUT
#            elif pin.xdr > 0:
#                i_type =     0b00 # PIN_INPUT_REGISTERED aka PIN_INPUT_DDR
#            if "o" not in pin.dir:
#                o_type = 0b0000   # PIN_NO_OUTPUT
#            elif pin.xdr == 0 and pin.dir == "o":
#                o_type = 0b0110   # PIN_OUTPUT
#            elif pin.xdr == 0:
#                o_type = 0b1010   # PIN_OUTPUT_TRISTATE
#            elif pin.xdr == 1 and pin.dir == "o":
#                o_type = 0b0101   # PIN_OUTPUT_REGISTERED
#            elif pin.xdr == 1:
#                o_type = 0b1101   # PIN_OUTPUT_REGISTERED_ENABLE_REGISTERED
#            elif pin.xdr == 2 and pin.dir == "o":
#                o_type = 0b0100   # PIN_OUTPUT_DDR
#            elif pin.xdr == 2:
#                o_type = 0b1100   # PIN_OUTPUT_DDR_ENABLE_REGISTERED
#            io_args.append(("p", "PIN_TYPE", C((o_type << 2) | i_type, 6)))
#
#            if hasattr(pin, "i_clk"):
#                io_args.append(("i", "INPUT_CLK",  pin.i_clk))
#            if hasattr(pin, "o_clk"):
#                io_args.append(("i", "OUTPUT_CLK", pin.o_clk))
#
#            if "i" in pin.dir:
#                if pin.xdr == 0 and is_global_input:
#                    io_args.append(("o", "GLOBAL_BUFFER_OUTPUT", pin.i[bit]))
#                elif pin.xdr < 2:
#                    io_args.append(("o", "D_IN_0",  pin_i[bit]))
#                elif pin.xdr == 2:
#                    # Re-register both inputs before they enter fabric. This increases hold time
#                    # to an entire cycle, and adds one cycle of latency.
#                    io_args.append(("o", "D_IN_0",  i0_ff[bit]))
#                    io_args.append(("o", "D_IN_1",  i1_ff[bit]))
#            if "o" in pin.dir:
#                if pin.xdr < 2:
#                    io_args.append(("i", "D_OUT_0", pin_o[bit]))
#                elif pin.xdr == 2:
#                    # Re-register negedge output after it leaves fabric. This increases setup time
#                    # to an entire cycle, and doesn't add latency.
#                    io_args.append(("i", "D_OUT_0", pin_o0[bit]))
#                    io_args.append(("i", "D_OUT_1", o1_ff[bit]))
#
#            if pin.dir in ("oe", "io"):
#                io_args.append(("i", "OUTPUT_ENABLE", pin.oe))
#
#            if is_global_input:
#                m.submodules["{}_{}".format(pin.name, bit)] = Instance("SB_GB_IO", *io_args)
#            else:
#                m.submodules["{}_{}".format(pin.name, bit)] = Instance("SB_IO", *io_args)
#
#    def get_input(self, pin, port, attrs, invert):
#        self._check_feature("single-ended input", pin, attrs,
#                            valid_xdrs=(0, 1, 2), valid_attrs=True)
#        m = Module()
#        self._get_io_buffer(m, pin, port.io, attrs, i_invert=invert)
#        return m
#
#    def get_output(self, pin, port, attrs, invert):
#        self._check_feature("single-ended output", pin, attrs,
#                            valid_xdrs=(0, 1, 2), valid_attrs=True)
#        m = Module()
#        self._get_io_buffer(m, pin, port.io, attrs, o_invert=invert)
#        return m
#
#    def get_tristate(self, pin, port, attrs, invert):
#        self._check_feature("single-ended tristate", pin, attrs,
#                            valid_xdrs=(0, 1, 2), valid_attrs=True)
#        m = Module()
#        self._get_io_buffer(m, pin, port.io, attrs, o_invert=invert)
#        return m
#
#    def get_input_output(self, pin, port, attrs, invert):
#        self._check_feature("single-ended input/output", pin, attrs,
#                            valid_xdrs=(0, 1, 2), valid_attrs=True)
#        m = Module()
#        self._get_io_buffer(m, pin, port.io, attrs, i_invert=invert, o_invert=invert)
#        return m
#
#    def get_diff_input(self, pin, port, attrs, invert):
#        self._check_feature("differential input", pin, attrs,
#                            valid_xdrs=(0, 1, 2), valid_attrs=True)
#        m = Module()
#        # See comment in should_skip_port_component above.
#        self._get_io_buffer(m, pin, port.p, attrs, i_invert=invert)
#        return m
#
#    def get_diff_output(self, pin, port, attrs, invert):
#        self._check_feature("differential output", pin, attrs,
#                            valid_xdrs=(0, 1, 2), valid_attrs=True)
#        m = Module()
#        # Note that the non-inverting output pin is not driven the same way as a regular
#        # output pin. The inverter introduces a delay, so for a non-inverting output pin,
#        # an identical delay is introduced by instantiating a LUT. This makes the waveform
#        # perfectly symmetric in the xdr=0 case.
#        self._get_io_buffer(m, pin, port.p, attrs, o_invert=    invert, invert_lut=True)
#        self._get_io_buffer(m, pin, port.n, attrs, o_invert=not invert, invert_lut=True)
#        return m
#
#    # Tristate bidirectional buffers are not supported on iCE40 because it requires external
#    # termination, which is different for differential pins configured as inputs and outputs.
#
#    # CDC primitives are not currently specialized for iCE40. It is not known if iCECube2 supports
#    # the necessary attributes; nextpnr-ice40 does not.
